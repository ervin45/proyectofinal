.. raw:: latex

   \maketitle

.. contents::


========================================================================
                            Introducción
========================================================================

------------------------------------------------------------------------
Temática
------------------------------------------------------------------------

La Empresa Ricardo C. Bieler se dedica a la comercialización de
vehículos (autos, camionetas y camiones), repuestos y servicios
relacionados con el rubro automotor. Tiene la concesión de venta
exclusiva de Mercedes-Benz, Chrysler, Jeep y Dodge. La empresa cuenta
con 60 empleados en diversas áreas, desde el salón comercial hasta un
importante taller. Posee dos sucursales en Reconquista y Rafaela.

La empresa Ricardo C. Bieler S.A. no posee, en la actualidad, un
sistema de soporte de decisiones en lo que se refiere a la compra y
venta de unidades (camiones, utilitarios y automóviles). En el caso de
los repuestos, los movimientos de entrada y salida se basan en
estimaciones por parte del personal actual con un soporte informático
mínimo.

Dentro de las competencias de un ingeniero en sistema se encuentran el
diseño, análisis e implementación de un sistema de soporte de
decisiones.

El presente proyecto propone utilizar técnicas aprendidas en el
transcurso de la carrera para diseñar un sistema que permita a los
dueños y gerentes de la firma obtener un diagnóstico estratégico de su
negocio.

Los productos existentes que brindan una parte de este tipo de
soluciones son: Agata Report, Jasper, Pentaho Reporting para reportes
y Mondrian, Palo para OLAP (On Line Analytical Processing). Como
soporte de datos para el modelado dimensional, utilizan Data
Warehouses sobre bases de datos como Oracle, MS-SQL Server, Postgre,
MySQL, entre otros.

------------------------------------------------------------------------
Problemática
------------------------------------------------------------------------

En el transcursos de los años en lo que funciona la empresa, esta ha
ido acumulando datos acerca de las operaciones que realiza para para
poder devenvolverse en su ambito de negocio. Todos estos datos solo
fueron acumulados en los sistemas internos que utiliza la empresa sin
la posibilidad de realizar un analisis mas completo que permita la
toma de decisiones en un nivel estrategico basado no solo en intuición
del empresario sino tambien en datos cuantitativos y objetivos.

La empresa no tenia una manera sencilla y eficaz de analizar sus datos
operacionales. No era posible realizar una comparacion de los datos en
diferentes variables en un tiempo razonable que permita la toma de
decisiones. Esto era un problema a la hora de decidir el tipo de
compras en materia de autos, camiones y repuestos para alcanzar
objetivos como ser maximizar las ganancias.

Ricardo C. Bieler S.A. consta de un casa central y dos sucursales en
la provincia. Las decisiones solo eran posibles desde el punto central
por ser el unico que tenia acceso a toda la información de la
empresa. Esto provocaba que el proceso de toma de decisiones estuviera
centralizado en muy pocas personas y los aportes de gerentes de las
sucursales fueran minimos. Por esta causa se hacia muy necesario tener
la posibilidad de acceder a las funcionalidades del sistema desde
cualquiera de estos puntos de decisión y asi agilizar los mecanismos
decisionales.

La lógica de almacenamiento de información empresarial en los últimos
años ha sido analizada y desarrollada bajo distintas ópticas. Data
Warehouse, propuesta por Bill Inmon y Ralph Kimball, entre otros, a
finales de los '90 demostró ser una de las formas más destacadas de
organizar, almacenar y visualizar la información crítica para ser
llevada a los niveles de decisión estratégica de las organizaciones.
Para la aplicación de esta técnica en la toma de decisiones es
necesario un volumen significativo de datos sensibles (como la
facturación).

En nuestro caso, Ricardo C. Bieler S.A. nos facilitó las bases de
datos de facturación de los últimos siete años, evitando la necesidad
de comenzar la tediosa tarea de recolección de los mismos en otra
empresa. Por otro lado el cliente tiene la imperiosa necesidad de
herramientas de diagnóstico y ayuda en la toma de decisiones para
mejorar el funcionamiento de su empresa, ya que en la actualidad no
existe ningún sistema que le brinde esta funcionalidad en tiempo real.

Debido a las características particulares de la estructura de sistemas
de información de la empresa, es necesario realizar adaptaciones a
medida para la generación de informes personalizados que sean de facil
generación y consulta. Las herramientas comerciales del mercado no
ofrecen la flexibilidad suficiente para esta tarea.

------------------------------------------------------------------------
Objetivos y alcances
------------------------------------------------------------------------

El sistema funcionará en las sucursales de Rafaela, Reconquista y casa
central en Santa Fe de Ricardo C. Bieler S.A. y los decisores podrán
consultarlo desde donde deseen a través de Internet.

El sistema permitirá la generación de informes semanales, alarmas y
sugerencias en la toma de decisiones para los gerentes y dueños de la
empresa, acerca de la totalidad de las unidades y repuestos comprados
y vendidos en los últimos siete años.

* Diseñar el Data WareHouse. Se diseñarán las tablas de hechos y
  dimensiones que responderán a los informes.

* Diseñar el ETL. Se desarrollara una herramienta que hará la
  extracción, transformación y carga de información en el Data
  Warehouse.

* Diseñar la arquitectura, esto implica relevar de requisitos no
  funcionales del sistema.

* Gestionar informes de Compra y Venta de Unidades (camiones y autos)

* Gestionar informes de Compra y Venta de Repuestos y accesorios

* Gestionar informes de Stock de Unidades.

* Gestionar informes de Stock de Repuestos.

* Gestionar informes de control de comisiones de taller mecánico.

* Gestionar informes comparativos de ventas entre las sucursales. La
  empresa tiene sucursales en Santa Fe, Rafaela y Reconquista.

* Gestionar informes comparativos de ventas de Mercedes Benz de
  Ricardo C. Bieler con las demás concesionarias del país.

* Gestionar Pronósticos de Ventas. El sistema permitirá realizar
  pronósticos de con distintas técnicas para mejorar la toma de
  decisiones.

* Permitir la gestión de alertas. El sistema debe permitir la
  definición de eventos importantes como vencimientos y encargarse de
  emitir el alerta correspondiente cuando este tiene lugar.

* Gestionar informes de seguimiento de compra en relación a objetivos
  de compra establecidos por los proovedores de unidades,
  principalmente Mercedes Benz y Chrysler.

* Diseñar la red de información que le dará conectividad al sistema de
  información.

* Emisión e impresión de reportes necesarios para la toma de
  decisiones.

* Gestión de usuarios. El sistema permitirá a la empresa definir
  diferentes roles con determinados permisos.


------------------------------------------------------------------------
Organización del documento
------------------------------------------------------------------------




------------------------------------------------------------------------
Terminología utilizada
------------------------------------------------------------------------

:Base de datos multidimensional: Es una base de datos con tablas que
      representan hechos (ejemplo: ventas, compras) y tablas que
      representan dimensiones sobre esos hechos (ejemplo: tiempo,
      sucursal, cliente).

:Data Warehouse: Coleccion de datos almacenados orientados a un
      determinado ambito cuyo. Es una copia de las transacciones de
      datos específicamente estructurada para la consulta y el
      análisis.

:OLAP: Es una solución utilizada en el campo de la llamada
       Inteligencia empresarial (o Business Intelligence) cuyo
       objetivo es agilizar la consulta de grandes cantidades de
       datos. Para ello utiliza estructuras multidimensionales (o
       Cubos OLAP) que contienen datos resumidos de grandes Bases de
       Datos o Sistemas Transaccionales (OLTP).

:ETL: Extracción, Transformación y Carga de datos. Referido
      normalmente al proceso de extraer datos de los almacenamientos
      necesarios, realizar un procesamientos o transformacion de estos
      y almacenarlos o cargarlos en la estructura del Data Warehouse

:Data Mining: proceso que consiste en la extracción de conocimiento
      procesable, implícito en las bases de datos. Es decir lograr
      sacar conclusiones utiles a partir de un conjunto de datos no
      orientado a estas.

:XMLA: XML ..for analysis


-----------------------------------------------------------------------
Data Warehouse
-----------------------------------------------------------------------

Definición
-------------------

Es una colección de datos orientada a un determinado ámbito (empresa,
organización, etc.), integrado, no volátil y variable en el tiempo,
que ayuda a la toma de decisiones en la entidad en la que se
utiliza. Se trata, sobre todo, de un expediente completo de una
organización, más allá de la información transaccional y operacional.

La definición no quedaria completa sin mensionar que la organización
de los datos no es lo unico que implica un datawarehouse. Ademas incluye
herramientas de análisis y consulta, y utilidades para la extracción,
transformación y carga de datos de diversos origenes de datos como
pueden ser sistemas empresariales, webs o planillas de cálculo.

Benficios
------------------

:Información accesible: los contenidos del Data WareHouse son
	     entendibles y navegables, y el acceso a ellos es
	     caracterizado por el rápido desempeño. Estos
	     requerimientos no tienen fronteras y tampoco limites
	     fijos. Cuando hablamos de entendible significa, que los
	     niveles de la información sean correctos y obvios. Y
	     Navegables significa el reconocer el destino en la
	     pantalla y llegar a donde queramos con solo un
	     clic. Rápido desempeño significa, bajo tiempo de espera.

:Información consistente: la información de una parte de la
	     organización puede hacerse coincidir con la información
	     de la otra parte de la organización. Si dos medidas de la
	     organización tienen el mismo nombre, entonces deben
	     significar la misma cosa. Y a la inversa, si dos medidas
	     no significan la misma cosa, entonces son etiquetados
	     diferentes. Información consistente significa,
	     información de alta calidad.

:Información adaptable y elástica: el Data WareHouse esta diseñado
	     para cambios continuos. Cuando se le hacen nuevas
	     preguntas al Data WareHouse, los datos existentes y las
	     tecnologías no cambian ni se corrompen. Cuando se agregan
	     datos nuevos al Data WareHouse, los datos existentes y
	     las tecnologías tampoco cambian ni se corrompen.

:Toma de decisiones: este es el objetivo fundamental y que justifica
      su existencia. El datawarehose presenta la materia prima para el
      proceso de toma de decisiciones, la información. Por esto el
      datawarehouse muchas veces se puede considerar el eje de los
      sistemas de soporte de decisiones.

Propiedades
-----------------

:Orientado a temas: Los datos en la base de datos estás organizados de
	   manera que todos los elementos de datos relativos al mismo
	   evento u objeto del mundo real están unidos entre sí.

:Variante en el tiempo: Los cambios producidos en los datos a lo largo
	  del tiempo quedan registrados para que los informes que se
	  puedan generar reflejen esas variaciones.

:No volátil: La información no se modifica ni se elimina, una vez
    almacenado un dato, éste se convierte en información de sólo
    lectura, y se mantiene para futuras consultas.

:Integrado: La base de datos contiene datos de sistemas operacionales
	    de la organización, sistemas externos y de cualquier dato
	    que se pueda conseguir en medios digitales. Esta
	    diversidad de datos debe ser consistentes para poder
	    obtener informes confiables y utiles.

Por otro lado una base de datos relacional posee las siguientes diferencias:

:Orientada a las aplicaciones: El diseño esta adaptado a los procesos
	   o funciones que debe gestionar la aplicación.

:Tiempo: Los datos almacenados no deben tener necesariamente un
	 relación temporal o clave temporal.

:Datos volátiles: Los datos ademas de ser leidos pueden ser
       modificados en cualquier momento que la aplicación lo requiera.


DataMarks
------------

Manaja conceptos similares a los de un datawarehouse, pero con la
diferencia de que estos estan orientados a la toma de decisiones a
nivel departamental en lugar de hacerlo para toda la
organización. 

Segun sigamos a Bill Inmon o a Raph Kimball la relación
entre un datawarehouse y un datamark será conciderablemente
distinta. Para Inmon el datamark es cargado desde el datawarehouse
mediante programas de carga, visión TOP-DOWN. Para Kimball el datamark
es una porcion del datawarehouse y es cargado directamente desde las
bases de datos operacionales, visión BOTTOM-UP.

Elementos que integran un Data Warehouse
-----------------------------------------

:Metadatos: son datos que que se refieren a los del datawarehouse. Su
	    función es ayudar a los analistas a localizar los
	    contenidos, guiar a los algoritmos utilizados para la
	    sumarización/agregación y describir el método por el cual
	    es dato fue transformado desde su estado original hasta el
	    que es mantenido en el datawarehouse.

:ETL: sabemos que los datos que se encuentran en el datawarehouse
      provienen de muchos origentes, el encargado de realizar la
      conciliación se llama ETL. Este componente es el encargado de
      realizar la extracción, transformación y carga de los datos
      hacia el datawarehouse. La extracción consite en obtener los
      datos nuevos de los origenes. La transformación se encarga de
      cambiar la forma de los datos y adaptarla a la que es necesaria
      en el datawarehouse, este el punto en todo el proceso que mas
      esfuerzo lleva. La carga es el proceso de escritura de los datos
      transformados en el datawarehouse, es el único proceso que
      escribe en el almacenamiento del datawarehouse.

:Monitorización: monitorea los datos en las fuentes e informa al ETL
		 los cambios de interes para el datawarehouse

------------------------------------------------------------------------
OLAP
------------------------------------------------------------------------

OLAP es el acrónimo en inglés de procesamiento analítico en línea
(On-Line Analytical Processing). Es una solución utilizada en el campo
de la llamada Inteligencia empresarial (o Business Intelligence) cuyo
objetivo es agilizar la consulta de grandes cantidades de datos. Para
ello utiliza estructuras multidimensionales (o Cubos OLAP) que
contienen datos resumidos de grandes Bases de Datos o Sistemas
Transaccionales (OLTP). Se usa en informes de negocios de ventas,
marketing, informes de dirección, minería de datos y áreas similares.

La razón de usar OLAP para las consultas es la velocidad de
respuesta. Una base de datos relacional almacena entidades en tablas
discretas si han sido normalizadas. Esta estructura es buena en un
sistema OLTP pero para las complejas consultas multitabla es
relativamente lenta. Un modelo mejor para búsquedas, aunque peor desde
el punto de vista operativo, es una base de datos multidimensional.
Éstas pueden verse como bases de datos de una sola tabla, su
peculiaridad es que por cada dimensión tienen un campo (o columna), y
otro campo por cada métrica o hecho, es decir estas tablas almacenan
registros cuyos campos son de la forma:

.. raw:: latex

   $$ (d_1,d_2,d_3,...,f_1,f_2,f_3,...) $$

Donde los campos 

.. raw:: latex

   $ d_i $

hacen referencia a las dimensiones de la tabla, y los campos 

.. raw:: latex

   $ f_i $

a las métricas o hechos que se quiere almacenar, estudiar o analizar.


Cubos OLAP
-----------

Nos referimos a cubos OLAP cuando hablamos de bases de datos
multidimensionales, en las cuales el almacenamiento físico de los
datos se realiza en vectores multidimensionales. Los cubos OLAP se
pueden considerar como una ampliación de las dos dimensiones de una
hoja de cálculo. Por ejemplo, una empresa podría analizar algunos
datos financieros por producto, por período de tiempo, por ciudad, por
tipo de ingresos y de gastos, y mediante la comparación de los datos
reales con un presupuesto. Estos parámetros en función de los cuales
se analizan los datos se conocen como dimensiones. Para acceder a los
datos sólo es necesario indexarlos a partir de los valores de las
dimensiones o ejes.

El almacenar físicamente los datos de esta forma tiene sus pros y sus
contras. Por ejemplo, en estas bases de datos las consultas de
selección son muy rápidas (de hecho, casi en tiempo real). Pero uno de
los problemas más grandes de esta forma de almacenamiento es que una
vez poblada la base de datos ésta no puede recibir cambios en su
estructura. Para ello sería necesario rediseñar el cubo.

En un sistema OLAP puede haber más de tres dimensiones, por lo que a
los cubos OLAP también reciben el nombre de hipercubos. Las
herramientas comerciales OLAP tienen diferentes métodos de creación y
vinculación de estos cubos o hipercubos

Dimensiones y jerarquías
------------------------

Cada una de las dimensiones de un cubo OLAP puede resumirse mediante
una jerarquía. Por ejemplo si se considera una escala (o dimensión)
temporal "Mayo de 2005" se puede incluir en "Segundo Trimestre de
2005", que a su vez se incluye en "Año 2005". De igual manera, otra
dimensión de un cubo que refleje una situación geográfica, las
ciudades se pueden incluir en regiones, países o regiones mundiales;
los productos podrían clasificarse por categorías, y las partidas de
gastos podrían agruparse en tipos de gastos. En cambio, el analista
podría comenzar en un nivel muy resumido, como por ejemplo el total de
la diferencia entre los resultados reales y lo presupuestado, para
posteriormente descender en el cubo (en sus jerarquías) para poder
observar con un mayor nivel de detalle que le permita descubrir en el
cubo los lugares en los que se ha producido esta diferencia, según los
productos y períodos.

Definición técnica
------------------

En teoría de bases de datos, un cubo OLAP es una representación
abstracta de la proyección de una relación de un RDBMS (Sistema
administrador de bases de datos relacionales). Dada una relación de
orden N, se considera la posibilidad de una proyección que dispone de
los campos X, Y, Z como clave de la relación y de W como atributo
residual. Categorizando esto como una función se tiene que:

.. raw:: latex

   $$   W : (X,Y,Z) \rightarrow W $$

Los atributos X, Y, Z se corresponden con los ejes del cubo, mientras
que el valor de W devuelto por cada tripleta (X, Y, Z) se corresponde
con el dato o elemento que se rellena en cada celda del cubo.

Debido a que los dispositivos de salida (monitores, impresoras, ...)
sólo cuentan con dos dimensiones, no pueden caracterizar fácilmente
cuatro dimensiones, es más práctico proyectar "rebanadas" o secciones
de los datos del cubo (se dice proyectar en el sentido clásico vector
analítico de reducción dimensional, no en el sentido de SQL, aunque
los dos conceptos son claramente análogos), tal vez la expresión:

.. raw:: latex

   $$    W : (X,Y) \rightarrow W $$

Aunque no se conserve la clave del cubo (al faltar el parámetro Z),
puede tener algún significado semántico, sin embargo, también puede
que una sección de la representación funcional con tres parámetros
para un determinado valor de Z también resulte de interés.

La motivación que hay tras OLAP vuelve a mostrar de nuevo el paradigma
de los informes de tablas cruzadas de los sistema de gestión de base
de datos de los 80. Se puede desear una visualización al estilo de una
hoja de cálculo, donde los valores de X se encuentran en la fila $1,
los valores de Y aparecen en la columna $A, y los valores de 

.. raw:: latex

  $ W: (X,Y) \rightarrow W $

se encuentran en las celdas individuales a partir de la celda $B2
y desde ahí, hacia abajo y hacia la derecha. Si bien se puede utilizar
el Lenguaje de Manipulación de Datos (o DML) de SQL para mostrar las
tuplas (X,Y,W), este formato de salida no es tan deseable como la
alternativa de tablas cruzadas. El primer método requiere que se
realice una búsqueda lineal para cada par (X,Y) dado, para determinar
el correspondiente valor de W, mientras que el segundo permite
realizar una búsqueda más convenientemente permitiendo localizar el
valor W en la intersección de la columna X apropiada con la fila Y
correspondiente.

Se ha desarrollado el lenguaje MDX (MultiDimensional eXpressions o
expresiones multidimensionales) para poder expresar problemas OLAP de
forma fácil. Aunque es posible traducir algunas sus sentencias a SQL
tradicional, con frecuencia se requieren expresiones SQL poco claras
incluso para las sentencias más simples del MDX. Este lenguaje ha sido
acogido por la gran mayoría de los proveedores de OLAP y se ha
convertido en norma de hecho para estos sistemas.


------------------------------------------------------------------------
Porque Python y no Java
------------------------------------------------------------------------

En el mercado de los lenguajes de programación Java se ha impuesto
gracias al concepto de la maquina virtual multiplataforma, una
plataforma que ofrece muchos servicios y a fuerza de mucho
marketing. Esto no quiere decir que Java deba se utilizado para
cualquier desarrollo como opción por defecto. 

En nuestro proyecto hemos elegido Python por ser un lenguaje que nos
hace posible maximizar nuestra velocidad de desarrollo y nos permite
pensar el problema desde una perspectiva de mayor nivel. Lenguajes
como Java o C suelen ser mas rapidos en la ejecución. A diferencia de
Java Python esta diseñado para ser una verdadera ayuda para el
desarrollador.

Python presenta una serie de ventajas que lo hacen muy atractivo,
tanto para su uso profesional como para el aprendizaje de la
programación. Está en un proceso de continuo desarrollo por una gran
comunidad de desarrolladores.

Se puede destacar de Python:

:Tiene una gran librería estándar: usada para una diversidad de
       tareas. Esto viene de la filosofía "baterías incluidas"
       ("batteries included") para módulos de Python.

:Es un lenguaje muy expresivo: es decir, los programas Python son muy
    compactos: un programa Python suele ser bastante más corto que su
    equivalente en lenguajes como Java. Python llega a ser considerado
    por muchos un lenguaje de programación de muy alto nivel.

:Es muy legible: la sintaxis de Python es muy elegante y permite la
    escritura de programas cuya lectura resulta más fácil que si
    utilizaremos otros lenguajes de programación. Esto es muy
    importante a la hora de realizar el mantenimiento en el
    futuro. Python ofrece un entorno interactivo que facilita la
    realización de pruebas y ayuda a despejar dudas acerca de ciertas
    características del lenguaje.

:Es un lenguaje de programación multiparadigma: esto significa que más
    que forzar a los programadores a adoptar un estilo particular de
    programación, permite varios estilos: programación orientada a
    objetos, programación estructurada y programación funcional.Posee
    un rico juego de estructuras de datos que se pueden manipular de
    modo sencillo.Python usa tipo de dato dinámico y fuerte

:Facil de extender: nuevos módulos se pueden escribir fácilmente en C
       o C++. Python puede utilizarse como un lenguaje de extensión
       para módulos y aplicaciones que necesitan de una interfaz
       programable.

Resumiendo, Python es un lenguaje ideal para realizar desarrollos en un fracción
de tiempo respecto a la mayoria de los lenguajes del mercado
reduciendo considerablemente los costos de desarrollo y lenguajes como
Java y C son mas apropiados cuando es muy alto el requerimiento de
performance. Como conclusión, nosotros pensamos que el tiempo de
desarrollo es un requisito mucho mas critico que la performance para
nuestro proyecto, hemos elegido Python.


------------------------------------------------------------------------
Metodología elegida
------------------------------------------------------------------------

La programación extrema o eXtreme Programming (XP) es un enfoque de la
ingeniería del Sofware. Consiste en un conjunto de prácticas que a lo
largo de los años han demostrado ser las mejores prácticas de
desarrollo de software, llevadas al extremo, fundamentadas en un
conjunto de valores.

Es la más destacada de los procesos ágiles de desarrollo de
software. Al igual que éstos, la programación extrema se diferencia de
las metodologías tradicionales principalmente en que pone más énfasis
en la adaptabilidad que en la previsibilidad.

Los defensores de XP consideran que los cambios de requisitos sobre la
marcha son un aspecto natural, inevitable e incluso deseable del
desarrollo de proyectos. Creen que ser capaz de adaptarse a los
cambios de requisitos en cualquier punto de la vida del proyecto es
una aproximación mejor y más realista que intentar definir todos los
requisitos al comienzo del proyecto e invertir esfuerzos después en
controlar los cambios en los requisitos. Se puede considerar la
programación extrema como la adopción de las mejores metodologías de
desarrollo de acuerdo a lo que se pretende llevar a cabo con el
proyecto, y aplicarlo de manera dinámica durante el ciclo de vida del
software.

Valores
-------


XP promueve una serie de valores que sientan los pilares los pilares
de la metodología. Estos valores son:


:Comunicación: los desarrolladores necesitan intercambiar información
	       e ideas sobre el proyecto, a los directivos, y a los
	       clientes de forma honrada, confiable y fácil. La
	       información debe fluir de manera continua y rápida.

:Sencillez: siempre que sea posible hay que elegir soluciones
	    simples. Esto no significa estar equivocado o aplicar
	    enfoques simplistas.

:Retroalimentación: en todos los niveles las personas deberían obtener
		    una retroalimentación muy rápida sobre lo que
		    hacen. Los clientes, los directivos y los
		    desarrolladores tienen que alcanzar una
		    comprensión común de la meta del proyecto, y
		    también acerca del estado actual del proyecto.

:Valor: cada persona implicada en el proyecto debería de tener el
	valor (y el derecho) de expresar su valoración sobre el
	proyecto. Todos deberían de tener el valor de ser abiertos y
	dejar que todos examinasen e incluso modificasen su trabajo.

Prácticas
---------

XP esta compuesta por un conjunto de practicas que están estrechamente
relacionadas y que aplicadas todas juntas son capaces de dar soporte a
las debilidades de cada practica. Estas practicas no son nuevas, sino
que han venido usando a lo largo de la corta historia del desarrollo
de software, la novedad radica en la utilización de estas prácticas de
forma conjunta y llevadas al extremo.

Las prácticas fundamentales de la metodología son: 

:Desarrollo iterativo e incremental: pequeñas mejoras, unas tras
	    otras.	

:Pruebas unitarias continuas: frecuentemente repetidas y
	 automatizadas. Se aconseja escribir el código de la prueba
	 antes de la codificación.

:Programación en Parejas: se recomienda que las tareas de desarrollo
	      se lleven a cabo por dos personas en un mismo puesto. Se
	      supone que la mayor calidad del código escrito de esta
	      manera -el código es revisado y discutido mientras se
	      escribe- es más importante que la posible pérdida de
	      productividad inmediata.

:Frecuente interacción: del equipo de programación con el cliente o
	   usuario Se recomienda que un representante del cliente
	   trabaje junto al equipo de desarrollo.

:Corrección de todos los errores antes de añadir nueva funcionalidad:
	    realizar entregas frecuentes.

:Refactorizacion del código: es decir, reescribir ciertas partes del
		 código para aumentar su legibilidad y mantenibilidad
		 pero sin modificar su comportamiento. Las pruebas han
		 de garantizar que en la refactorización no se ha
		 introducido ningún fallo.

:Propiedad del código compartida: en vez de dividir la responsabilidad
	   en el desarrollo de cada módulo en grupos de trabajo
	   distintos, este método promueve el que todo el personal
	   pueda corregir y extender cualquier parte del proyecto. Las
	   frecuentes pruebas de regresión garantizan que los posibles
	   errores serán detectados.


:Simplicidad en el código: es la mejor manera de que las cosas
	     funcionen. Cuando todo funcione se podrá añadir
	     funcionalidad si es necesario. La programación extrema
	     apuesta que en más sencillo hacer algo simple y tener un
	     poco de trabajo extra para cambiarlo si se requiere, que
	     realizar algo complicado y quizás nunca utilizarlo.

Etapas del proceso
--------------------

Cabe aclarar que el orden en el que son citadas las etapas no indica
el orden de seguimiento de estas sino una aproximación. En XP se
trabaja pasando en forma constante de una etapa a la otra en la
medida de lo posible. Las etapas son las siguientes:

Plantificación
------------------

Se escriben historias, cuya idea principal es describir un caso de uso
en dos o tres líneas con terminología del cliente (de hecho, se supone
que deben ser escritos por el mismo), de tal manera que se creen test
de aceptación para la y permita hacer una estimación de tiempo de
desarrollo del mismo.  Se crea un plan de lanzamiento que debe servir
para crear un calendario que todos puedan cumplir y en cuyo desarrollo
hayan participado todas las personas involucradas en el proyecto. Se
usará como base las historias, participando el cliente en la elección
de los que se desarrollarán, y según las estimaciones de tiempo de los
mismos se crearán las iteraciones del proyecto.  El desarrollo se
divide en iteraciones, cada una de las cuales comienza con un plan de
iteración para el que se eligen las historias a desarrollar y las
tareas de desarrollo.

Diseño
------


Se eligen los diseños más simples que funcionen.

Se elige una metáfora del sistema para que el nombrado de clases,
etcétera, siga una misma línea, facilitando la reutilización y la
comprensión del código.

Se "refactoriza sin piedad". Básicamente, consiste en no tener miedo
de cambiar un diseño o eliminar un código que ya no sirve, o al menos
que ya no es claramente la mejor solución.

Codificación
------------

El cliente está siempre disponible, a ser posible cara a cara. La idea
es que forme parte del equipo de desarrollo, y esté presente en todas
las fases de XP. La idea es usar el tiempo del cliente para estas
tareas en vez de para que cree una detalladísima especificación de
requisitos, y evitar la entrega de un producto peor que le hará perder
tiempo.

El código se ajustará a unos estándares de codificación, asegurando la
consistencia y facilitando la comprensión y refactorización del
código.  Las pruebas unitarias se codifican antes que el código en sí,
haciéndo que la codificación de este último sea más rápida, y que
cuando se afronte la misma se tenga más claro qué objetivos tiene que
cumplir lo que se va a codificar.

La programación del código se realizará en parejas, para aumentar la
calidad del mismo.

Se integra código y se lanza dicha integración de manera frecuente,
evitando divergencias en el desarrollo y permitiendo que todo el mundo
trabaje con la última versión del desarrollo. De esta manera, se
evitará pasar grandes periodos de tiempo integrando el código al final
del desarrollo, ya que las incompatibilidades habrán sido detectadas
enseguida.

Se usa la propiedad colectiva del código, lo que se traduce en que
cualquier programador puede cambiar cualquier parte del código. El
objetivo es fomentar la contribución de ideas por parte de todo el
equipo de desarrollo

Pruebas
-------

Todo el código debe tener pruebas unitarias, y debe pasarlas antes de
ser lanzado.

Cuando se encuentra un error de codificación o bug, se desarrollan
pruebas para evitar volver a caer en el mismo.

Se realizan pruebas de aceptación frecuentemente, publicando los
resultados de las mismas. Estas pruebas son generadas a partir de las
historias elegidas para la iteración, y son "pruebas de caja negra",
en las que el cliente verifica el correcto funcionamiento de lo que se
está probando.

Cuando se pasa la prueba de aceptación, se considera que la
correspondiente historia se ha completado.

Documentación
-------------

Al utilizar la metodología XP, el grupo de desarrollo no documenta de
la misma manera que en las metodologías tradicionales. La
documentación relevante en esta metodología es: aquella intrínseca del
código como comentarios, estándares de codificación, las historias de
usuarios, los casos de prueba, entre otros.

Por otra parte, la comunicación oral de manera informal es incentivada
por esta metodología y la formalización por escrito de los
procedimientos es mínima en comparación con las metodologías
tradicionales. Realizaremos documentación de mantenimiento del sistema
para futuras mejoras y expansiones.

-----------------------------------------------------------------------
Integración con Subversion (SVN)
-----------------------------------------------------------------------

A continuación se explicará brevemente la forma en la que se han ido
integrando los cambio a lo largo del proyecto con la utilización de la
herramienta SVN.

Ya sabemos que la metodologia XP tiene como una de sus prácticas la
integración del codigo fuente u otro tipo de archivos que sean
modificados por uno o mas desarrolladores, pero no es exclusivo de XP
sino que puede ser aprovechada por cualquier metodologia estandar o
híbrida. Para este propósito se utilizó SVN.

SVN es un herramienta para el control de versiones de
archivos. Permite sacar fotografias del proyecto en cualquier momento
del desarrollo, volver a cualquiera de esos puntos, mesclar los
cambios realizados por mas de un desarrollador sobre un archivo y
resolver conflictos. Su arquitectura es cliente/servidor. En el
servidor se encuentra el repositorio de datos que es donde se
almacenarán todas las versiones y en cada uno de los clientes habrá
una copia de trabajo que estará sincronizada con la del servidor.

Lo primero que hay que hacer es crear una copia de trabajo en la
maquina clientemediante una operación de CHECK OUT. El ciclo de
trabajo consiste en actualizar, realizar cambios, enviar cambios. La
actualización se realiza con la operación UPDATE para obtener los
cambios nuevos en el repositorio. Luego se realizan cambios en la
copia local, entre los mas importantes que se pueden hacer sobre un
archivo estan: modificar su contenido, marcarlo para agregar o
marcarlo para borrar. Por ultimo todos estos cambios que se hicieron
sobre uno o mas archivos deben ser sincronizados mediante la operación
COMMIT. Tanto en el uso de UPDATE como de COMMIT puede surgir lo que
se conoce como un conflicto. Estos conflictos se deben a que mas de un
desarrollador modifico la misma para de un archivo sin haber notado
los cambios que realizo el otro, pero gracias a SVN es bastante
sencillo de resolver y continuar asi un desarrollo consistente.

------------------------------------------------------------------------
Estandares de codificación adoptados
------------------------------------------------------------------------

Los siguientes estandares de codificación fueron adoptados por el equipo
de desarrollo:

* Identación con 4 espacios
* Nombres de variables en minusculas
* Nombres de funciones de en minúsculas y con guiones bajos (ejemplo: obtener_peticion(), realizar_informe())
* ...

------------------------------------------------------------------------
Estructura de numeracion de repuestos
------------------------------------------------------------------------

Mercedez Benz posee un sistema de identificacion de partes muy particular.

Detallamos parte los componentes en el numero identificacatorio:

.. image :: numeracion_mercedes_benz.eps

Fue muy importante conocer la nomenclatura de los elementos de
Mercedes Benz, porque la jerarquía de elementos no es intuitiva, al
menos no inicialmente. Se detalla a continuación la jerarquia de los
elementos de tipo A (Elementos Constructivos):

* Grupo Constructivo
* Modelo o Baumuster
* Identificación de pieza
* Numero de modificación

El sistema legacy (Octosis) incorporó campos finales que identifican,
por ejemplo, el proveedor. Logrando en algunos casos hasta 27 numeros
para caracterizar una pieza en particular. Estos datos eran usados
para completar las dimensiones de los cubos.

Los grupos constructivos se dividen en 2 partes, la primera de ellas son
números del 00 al 99 que clasifican al elemento de la siguiente manera:

* Piezas de motor: Grupos del 01 al 23, 25 y 54
* Piezas de chasis: Grupos del 24 al 59
* Piezas de cabina/carrocería: Grupos del 60 a 97
* Piezas en general: Grupos 98 y 99

Esta división se expande a un total de 1000 subgrupos, que no viene al
caso mencionarlos en este proyecto.


========================================================================
                        Tecnología Investigada
========================================================================

.. estructura gral un párrafo explica QUE ES, 2do parrafo Nuestra
   experiencia. Tercer parrafo: veredicto.


------------------------------------------------------------------------
Java y aplicaciones Tomcat
------------------------------------------------------------------------

Java es un lenguaje de programación de propósito general orientado a
objetos desarrollado por Sun Microsystems a principios de los años
90. Las aplicaciones Java están típicamente compiladas en un bytecode
que es interpretado o compilado a código nativo para su ejecución.

Las aplicaciones libres existentes con funcionalidades de Data
Warehouse, OLAP o similares, están en su mayoría implementadas en
Java. La suite de herramientas Pentaho[1], posee varias herramientas
para realizar ETL, Data Mining, etc. todas implementadas sobre Tomcat[2].

.. [1] http://www.pentaho.com
.. [2] http://tomcat.apache.org

En el comienzo del proyecto, investigamos la suite Pentaho, en particular el
producto Mondrian descripto en la sección ..., y nos resultó muy complicada la
instalación y configuración.

Una vez configurado, la performance de la aplicación Java era muy
pobre. Entonces decidimos ver alternativas.

------------------------------------------------------------------------
Python
------------------------------------------------------------------------

Python es un lenguaje de programación creado por Guido van Rossum en
el año 1990[3].

.. [3] http://svn.python.org/view/python/trunk/Misc/HISTORY?rev=51814&view=markup

Es comparado habitualmente con TCL, Perl, Scheme, Java y Ruby. En la6500
actualidad Python se desarrolla como un proyecto de código abierto,
administrado por la Python Software Foundation. La última versión
estable del lenguaje es actualmente la 2.5.1 (18 de abril de 2007)(Se
anunció la llegada de la versión 3.0 para el 2008).

------------------------------------------------------------------------
XPWeb
------------------------------------------------------------------------

Es una herramienta web para administrar proyectos que siguen la
metodologia XP. Con esta herramienta es posible realizar la
planificación, gestionar las metaforas, utilizar un calendario,
imprimir reportes con estadisticas y exportar proyectos. Desarrollada
en el lenguaje PHP y de libre uso y distribucion.

Para la planificación permite representar iteraciones, historias de
usuarios y tareas. Es posible introducir tiempos de estimación para la
realización de las tareas e historias y en base a esto realiza
estadisticas de cumplimientos de fechas límite y advierte en pantalla
acerca de vencimientos proximos.

Al ser una herramienta web es de muy facil instalación y publicación,
gracias a ello es muy sencillo acceder a su contenido y edición por
parte de todo el equipo implicado en el desarrollo y planificación del
proyecto.

------------------------------------------------------------------------
Turbo Gears
------------------------------------------------------------------------

Es un framework de desarrollo web para Python. Subdivide el problema
du una aplicación web en capas que interactuan entre si. La filosofía
del proyecto es la reutilización de tecnologías existentes
maduras. Las tecnologías utilizadas son:

:MochiKit: es una biblioteca para simplificar el desarrollo en Javascript.

:Kid: es un sistema de templates amigable tanto para el diseñador
      gráfico como para el programador.

:CherryPy: es una biblioteca para manejar de manera sencilla el
	   entrada/salida de los sistemas web en Python.

:SQLObject: tratamiento de objetos con persistencia de objetos en
	    bases de datos relacionales sin una ocultación total de la
	    base de datos.

El comienzo del proyecto fue realizado en Turbo Gears pero encontramos
algunas debilidades como por ejemplo:

* En caso de error los informes eran escasos y ambigüos.

* La comunidad de desarrolladores del proyecto no respondía de la
  manera esperada.

* La documentación del proyecto estaba desactualizada e incompleta.

------------------------------------------------------------------------
Django
------------------------------------------------------------------------

Django es un framework para desarrollo web en Python basado en el
patron de diseño MVC (Model-View-Controller). A diferencia de Turbo
Gears no se apoya en tecnologías existentes, sino implementa cada una
de las 3 capas logrando una integración superior.

También posee herramientas para un correcto mapeo entre las URLs a
utilizar en la aplicación y los métodos a ser llamados. De esta forma
se pueden realizar cambios de comportamiento sin que afecte la
perspectiva del usuario/cliente web. Esta característica nos brindó la
posibilidad de prototipado rápido y adaptaciones sucesivas.

Una de las premisas del proyecto es el feedback hacia el programador
en el momento del desarrollo de la aplicacion. Nos sorprendió el nivel
de detalle en los informes de errores y las opciones de depuración de
código, esto nos posibilitó acortar los tiempos de iteración en el
desarrollo.

------------------------------------------------------------------------
Turbo Gear vs. Django
------------------------------------------------------------------------

Luego de probar ambas tecnologías encontramos ventajas y desventajas
en ambas:

Turbo Gear (pros-contras)
--------------------------------

* malisimo

Django (pros-contras)
--------------------------------

* buenisimo.

Nos decidimos por Django

------------------------------------------------------------------------
Mondrian
------------------------------------------------------------------------

Según su propia descripcion:

"Mondrian es un servidor OLAP escrito en Java. Permite analizar
interactivamente conjuntos de datos de gran tamaño guardados en base
de datos SQL sin escribir SQL."

Mondrian es parte de la suite de Inteligencia de Negocios de Pentaho,
y ofrece una interfaz XMLA para consultas multidimensional. Es el lenguaje
de facto en el área, impuesto por SQL Server 2000 de Microsoft.

Nuestra experiencia fue negativa con Mondrian, principalmente por
la incompatibilidad de las herramientas libres disponibles y su
implementación de XMLA. 

------------------------------------------------------------------------
Exportacion XBase -> SQL
------------------------------------------------------------------------

Los datos de la empresa estaban almacenados en datos XBase (conocidas
popularmente por sus archivos .dbf), de acceso lento y sin integridad
referencial.

Inicialmente, el volumen de datos a trabajar era de 2.0 Gigabytes,
distribuidos más de 1000 archivos. Esto requería de una opción más
confiable y veloz, por lo que decidimos migrarlos utilizando
dbf2mysql hacia un motor de base de datos relacional como es MySQL.

Luego utilizamos SQL para extraer los datos y crear las bases de datos
multidimensional

------------------------------------------------------------------------
AJAX
------------------------------------------------------------------------

AJAX, acrónimo de Asynchronous JavaScript And XML (JavaScript
asíncrono y XML), es una técnica de desarrollo web para crear
aplicaciones interactivas. Actualmente es soportada por la mayoria de los
navegadores web.

Ajax no es una tecnología en sí mismo. En realidad, se trata de la
unión de varias tecnologías que se desarrollan de forma autónoma y que
se unen de formas nuevas y sorprendentes. Entre otras tecnologias que
integran AJAX se encuentran JavaScript, XML y CSS.

En las aplicaciones web tradicionales, las acciones del usuario en la
página desencadenan llamadas al servidor. Una vez procesada la
petición del usuario, el servidor devuelve una nueva página HTML al
navegador del usuario. Mediante el uso de AJAX las aplicaciones se
ejecutan en el cliente, es decir, en el navegador de los usuarios y
mantiene comunicación asíncrona con el servidor en segundo plano. De
esta forma es posible realizar cambios sobre la misma página sin
necesidad de recargarla. Esto significa aumentar la interactividad,
velocidad y usabilidad en la misma.

------------------------------------------------------------------------
Postgre
------------------------------------------------------------------------

PostgreSQL es un Sistema de Gestión de Bases de Datos
Objeto-Relacionales (ORDBMS) que ha sido desarrollado de varias formas
desde 1977. Comenzó como un proyecto denominado Ingres en la
Universidad Berkeley de California. Ingres fue más tarde desarrollado
comercialmente por la Relational Technologies/Ingres Corporation.

En 1986 otro equipo dirigido por Michael Stonebraker de Berkeley
continuó el desarrollo del código de Ingres para crear un sistema de
bases de datos objeto-relacionales llamado Postgres. En 1996, debido a
un nuevo esfuerzo de código abierto y a la incrementada funcionalidad
del software, Postgres fue renombrado a PostgreSQL, tras un breve
periplo como Postgres95. El proyecto PostgreSQL sigue actualmente un
activo proceso de desarrollo a nivel mundial gracias a un equipo de
desarrolladores y contribuidores de código abierto.

========================================================================
                             Desarrollo
========================================================================

.. En este capitulo explicamos las elecciones de diseño, el transcurso
   de la implementacion etc. etc



------------------------------------------------------------------------
                          Servidor de cubos
------------------------------------------------------------------------


Introducción
------------------------------------------------------------------------

En los primeros meses de este proyecto, la arquitectura inicial
elegida, era la siguiente:

[Grafico con mondrian como server de cubos]

En la implemenación de esta arquitectura tuvimos dificultades en las
instalación, parametrización y utilización del servidor OLAP (Mondrian).
A continuación una resumida lista de problemas encontrados:

* No poseiamos experiencia en la administración del servidor de
  aplicaciones Tomcat.

* Existían diferencias substanciales entre las distintas
  instalaciones, sobre todo en el aspecto de seguridad dependiendo de
  la distribución de GNU/Linux elegida.

* La configuración de los cubos y los cubos virtuales eran realizadas
  en un complejísimo archivo XML donde habitualmente teníamos
  inconsistencias.

* No poseíamos experiencia en el lenguaje de consulta MDX y a medida
  que lo utilizábamos nos dábamos cuenta que la implementación en
  Modrian es escasa y errónea en algunas características.

* La implementación del protocolo XMLA (XML+SOAP) es incompatible con
  las bibliotecas de SOAP de Python (SOAPy) y luego de hacer nuestro
  propia implementación, las bibliotecas estándares XML no podían
  procesar la salida de Mondrian (que coincide perfectamente con las
  salidas de SQL server 2000 de Microsoft)

Estos inconvenientes nos llevaron a evaluar la posibilidad de realizar
nuestro propio servidor de cubos utilizando un soporte de base de
datos relacional. Evaluamos el subconjunto de funcionalidades
necesarias y posibles optimizaciones basadas en nuestra necesidad, y
desarrollamos cubículo.

Cubículo
------------------------------------------------------------------------

La piedra fundamental de cubículo es la descripción de un determinado
informe a obtener. Los parámetros necesiarios son:

:Hecho: es el conjunto de datos individuales y las columnas a
	relacionarlas con las dimensiones.

:Ejes: son dos dimensiones que serán los ejes de la
       tabla del informe

:Restricciones: son ecuaciones a realizar sobre los niveles de las
		dimensiones, tanto las elegidas como ejes como otras
		que posee el hecho

:Medidas: son los elementos individuales que podrán ser sumarizados (u
	  otros tipos de agregación),

:Funcion: es para el postprocesamiento del cubo

------------------------------------------------------------------------
ETL
------------------------------------------------------------------------

========================================================================
                            Documentación
========================================================================

------------------------------------------------------------------------
Juego de la planificacion
------------------------------------------------------------------------

.. include:: versiones-iteraciones-historias.txt

------------------------------------------------------------------------
Tests
------------------------------------------------------------------------

========================================================================
                             Conclusiones
========================================================================



========================================================================
                                Anexos
========================================================================

------------------------------------------------------------------------
Herramientas: Subversion
------------------------------------------------------------------------

El principal objetivo de Subversion (conocido popularmente como SVN)
es la administración de código fuente entre distintos
programadores. Pueden estar separados geográficamente (o bien realizar
cambios de forma asincróna) y mantener de manera simple un repositorio
central y con metadatos relacionados al proceso de desarrollo.

Se pueden restituir versiones anteriores del proyecto como también
generar nuevas ramas de desarrollo, por ejemplo para experimentación
de una funcionalidad en concreto.

------------------------------------------------------------------------
Herramientas: Wiki
------------------------------------------------------------------------

Las anotaciones del proyecto las realizamos con una herramientas web
de filosofía Wiki, provista por Google Code[4]. Esto nos permitió
realizar una base de conocimientos en hipertexto de manera sencilla y
rápida.

.. [4] http://code.google.com/p/proyectofinal



------------------------------------------------------------------------
Herramientas: ReStructured Text (RST)
------------------------------------------------------------------------

------------------------------------------------------------------------
Código de cubículo
------------------------------------------------------------------------

------------------------------------------------------------------------
Guias de instalación de componentes
------------------------------------------------------------------------

Django
------

Postgre
-------

Tareas periódicas (cron)
------------------------

------------------------------------------------------------------------
Licencia GPL
------------------------------------------------------------------------

La licencia pública general de GNU o mas conocida por su nombre en
inglés GNU General Public License o simplemente su acrónimo del inglés
GNU GPL. 

Es una licencia creada por la Free Software Foundation a mediados de
los 80, y está orientada principalmente a proteger la libre
distribución, modificación y uso de software. Su propósito es declarar
que el software cubierto por esta licencia es software libre y
protegerlo de intentos de apropiación que restrinjan esas libertadesa
los usuarios.

.. raw:: latex

  \begin{thebibliography}{90}
 
  \bibitem{lamport94}
    Leslie Lamport,
    \emph{\LaTeX: A Document Preparation System}.
    Addison Wesley, Massachusetts,
    2nd Edition,
    1994.
   
  \bibitem{pilgrim07}
    Mark Pilgrim,
    \emph{Dive into python},
    http://www.diveintopython.org,
    2004

  \bibitem{ramm}
    Mark Ramm, Kevin Dangoor, Gigi Sayfan,
    \emph{Rapid Web Application with TurboGears;
    Using Python to Create Ajax-Powered Sites},
    Prentice Hall,
    1ra Edicion,
    2005

  \bibitem{amk}
    A. M. Kuchling,
    \emph{XML for Analysis Specification version 1.1},
    http://www.amk.ca/talks/2006-02-07,
    2006

  \bibitem{lundh}
    Fredrik Lundh,
    \emph{Elements and Element Trees},
    http://effbot.org/zone/element.htm
    2007

  \bibitem{dbook}
    Adrian Holovaty, Jacob Kaplan-Moss,
    \emph{The definitive guide to Django}
    Apress,
    1ra Edicion,
    2007

  \bibitem{django}
    Adrian Holovaty, Jacob Kaplan-Moss,
    \emph{The web framework for perfectionists with deadlines},
    http://www.djangoproject.com,
    2008

  \bibitem{apache}
    Roberto Zoia,
    \emph{Como correr Django en Apache},
    http://tinyurl.com/5w4gda,
    2006

  \bibitem{modelo}
    Tomás Casquero,
    \emph{Modelo de datos de Django},
    http://tinyurl.com/5nncvz,
    2008

  \bibitem{mddatasets}
    Microsoft Corporation,
    \emph{Especificacion de MDDataSets},
    http://msdn2.microsoft.com/en-us/library/ms186704.aspx,
    2002

  \bibitem{execute}
    Microsoft Corporation,
    \emph{SQL Server TechCenter, Execute Method(XMLA)},
    http://technet.microsoft.com/en-us/library/ms186691.aspx,
    2007

  \bibitem{soapxml}
    Marek Pikulski,
    \emph{XMLA 1.1 'Execute'-requests - SOAP/XML namespace problems}
    http://tinyurl.com/5vz3wn,
    2004

  \bibitem{psqldoc}
    The PostgreSQL Global Development Group,
    \emph{PostgreSQL, Documentation}
    http://www.postgresql.org/docs/8.3/static/index.html,
    2008

  \bibitem{guiaubuntu}
    \emph{Guia Ubuntu, sección PostgreSQL}
    http://www.guia-ubuntu.org/index.php?title=PostgreSQL,
    2007

  \bibitem{psqlvsmysql}
    Mark Kaletka, Irwin Gaines,
    \emph{PostgreSQL or MySQL?}
    http://www-css.fnal.gov/dsg/external/freeware/pgsql-vs-mysql.html,
    2005

  \bibitem{wikidwh}
    Wikipedia, la enciclopedia libre,
    \emph{Data Warehouse},
    http://en.wikipedia.org/wiki/Data\_warehouse,
    2008

  \bibitem{wikiolap}
    Wikipedia, la enciclopedia libre,
    \emph{OLAP},
    http://en.wikipedia.org/wiki/OLAP,
    2008

  \bibitem{gutierrez}
    Damián Gutiérrez Echeverría, Universidad Iberoamericana
    \emph{Data Warehouse}
    http://tinyurl.com/64nxxf,

  \bibitem{catedra}
    Catedra de Sistemas de Gestion II,
    \emph{Apuntes de la catedra},
    http://tinyurl.com/6m58ta
    2007

  \bibitem{russell}
    Roberta Russell, Bernard W. Taylor III,
    \emph{Operation Management},
    Ed. Prentice Hall,
    1998

  \bibitem{hanke}
    John E. Hanke, Arthur G. Reitsgh,
    \emph{Pronósticos en los negocios},
    Prentice Hall,
    1996
    
  \end{thebibliography}

